"""
Management command para ejecutar el bot de Telegram del taller mecÃ¡nico.

Este comando inicia el bot que permite a los clientes:
- Recibir un saludo de bienvenida
- Ser guiados paso a paso para crear citas
- Seleccionar servicios con botones
- Ingresar informaciÃ³n de vehÃ­culo y contacto
- Confirmar y guardar la cita como reparaciÃ³n disponible para mecÃ¡nicos

Uso:
    python manage.py run_telegram_bot

El bot se ejecutarÃ¡ en modo polling (ideal para desarrollo).
Para producciÃ³n, considerar cambiar a webhooks.
"""

import os
import logging
from django.core.management.base import BaseCommand
from django.conf import settings
from asgiref.sync import sync_to_async
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ConversationHandler, filters, ContextTypes
from gestion.models import Cliente, Vehiculo, Servicio, Reparacion

# Configurar logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Estados de la conversaciÃ³n
START, PHONE, NAME, VEHICLE_BRAND, VEHICLE_MODEL, VEHICLE_YEAR, VEHICLE_PLATE, SERVICE_SELECT, CONFIRMATION = range(9)

class Command(BaseCommand):
    help = 'Ejecuta el bot de Telegram para el taller mecÃ¡nico'

    def handle(self, *args, **options):
        """Inicia el bot de Telegram"""
        
        # Obtener token del bot (deberÃ­a estar en settings.py o variables de entorno)
        bot_token = getattr(settings, 'TELEGRAM_BOT_TOKEN', None)
        if not bot_token:
            bot_token = os.getenv('TELEGRAM_BOT_TOKEN')
        
        if not bot_token:
            self.stdout.write(
                self.style.ERROR('TELEGRAM_BOT_TOKEN no estÃ¡ configurado en settings.py o variables de entorno')
            )
            return

        # Crear aplicaciÃ³n del bot
        application = Application.builder().token(bot_token).build()

        # Crear manejador de conversaciÃ³n
        conv_handler = ConversationHandler(
            entry_points=[CommandHandler('start', start_command)],
            states={
                START: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_phone)],
                PHONE: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_name)],
                NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_vehicle_brand)],
                VEHICLE_BRAND: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_vehicle_model)],
                VEHICLE_MODEL: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_vehicle_year)],
                VEHICLE_YEAR: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_vehicle_plate)],
                VEHICLE_PLATE: [CallbackQueryHandler(select_service)],
                SERVICE_SELECT: [CallbackQueryHandler(select_service)],
                CONFIRMATION: [CallbackQueryHandler(confirm_appointment)],
            },
            fallbacks=[CommandHandler('cancel', cancel_command)],
            per_user=False,  # Cambiado de True a False
            per_chat=True,
            allow_reentry=True
        )

        # Agregar manejadores
        application.add_handler(conv_handler)
        application.add_handler(CommandHandler('help', help_command))

        # Iniciar el bot
        self.stdout.write(self.style.SUCCESS('ğŸ¤– Bot de Telegram iniciado...'))
        application.run_polling(allowed_updates=Update.ALL_TYPES)


async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja el comando /start - punto de entrada del bot"""
    
    # DEBUG: Log para verificar si se estÃ¡ llamando esta funciÃ³n
    logger.info(f"ğŸ¯ COMANDO /START RECIBIDO de usuario: {update.effective_user.username}")
    print(f"ğŸ¯ COMANDO /START RECIBIDO de usuario: {update.effective_user.username}")
    
    user = update.effective_user
    
    welcome_message = f"""
ğŸ”§ *Â¡Bienvenido al Taller MecÃ¡nico!* ğŸ”§

Hola {user.first_name}! ğŸ‘‹
Soy el asistente virtual del taller y te ayudarÃ© a agendar tu cita.

Para comenzar, necesito algunos datos:
ğŸ“± Tu nÃºmero de telÃ©fono
ğŸ‘¤ Tu nombre completo
ğŸš— InformaciÃ³n de tu vehÃ­culo
âš™ï¸ El servicio que necesitas
ğŸ“… Fecha y hora preferida

Por favor, envÃ­ame tu nÃºmero de telÃ©fono para continuar:
"""
    
    try:
        await update.message.reply_text(
            welcome_message,
            parse_mode='Markdown'
        )
        logger.info("âœ… Mensaje de bienvenida enviado exitosamente")
        print("âœ… Mensaje de bienvenida enviado exitosamente")
        return START
    except Exception as e:
        logger.error(f"âŒ Error al enviar mensaje de bienvenida: {e}")
        print(f"âŒ Error al enviar mensaje de bienvenida: {e}")
        return ConversationHandler.END


async def get_phone(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Obtiene el nÃºmero de telÃ©fono del cliente"""
    phone = update.message.text.strip()
    
    # ValidaciÃ³n bÃ¡sica del telÃ©fono
    if not phone.replace('+', '').replace('-', '').replace(' ', '').isdigit():
        await update.message.reply_text(
            "âŒ Por favor, ingresa un nÃºmero de telÃ©fono vÃ¡lido.\n"
            "Ejemplo: +595 981 234567 o 0981234567"
        )
        return START
    
    # Guardar telÃ©fono en contexto
    context.user_data['phone'] = phone
    
    await update.message.reply_text(
        f"âœ… TelÃ©fono guardado: {phone}\n\n"
        "Ahora, por favor envÃ­ame tu nombre completo:"
    )
    
    return PHONE


async def get_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Obtiene el nombre del cliente"""
    name = update.message.text.strip()
    
    if len(name) < 3:
        await update.message.reply_text(
            "âŒ Por favor, ingresa tu nombre completo (mÃ­nimo 3 caracteres):"
        )
        return PHONE
    
    # Guardar nombre en contexto
    context.user_data['name'] = name
    
    await update.message.reply_text(
        f"âœ… Nombre guardado: {name}\n\n"
        "Ahora necesito la informaciÃ³n de tu vehÃ­culo.\n\n"
        "Â¿CuÃ¡l es la marca de tu vehÃ­culo? (Ej: Toyota, Ford, Volkswagen)"
    )
    
    return NAME


async def get_vehicle_brand(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Obtiene la marca del vehÃ­culo"""
    brand = update.message.text.strip().capitalize()
    
    if len(brand) < 2:
        await update.message.reply_text(
            "âŒ Por favor, ingresa una marca vÃ¡lida:"
        )
        return VEHICLE_BRAND
    
    context.user_data['vehicle_brand'] = brand
    
    await update.message.reply_text(
        f"âœ… Marca: {brand}\n\n"
        "Â¿CuÃ¡l es el modelo de tu vehÃ­culo? (Ej: Corolla, Focus, Gol)"
    )
    
    return VEHICLE_BRAND


async def get_vehicle_model(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Obtiene el modelo del vehÃ­culo"""
    model = update.message.text.strip().capitalize()
    
    if len(model) < 2:
        await update.message.reply_text(
            "âŒ Por favor, ingresa un modelo vÃ¡lido:"
        )
        return VEHICLE_MODEL
    
    context.user_data['vehicle_model'] = model
    
    await update.message.reply_text(
        f"âœ… Modelo: {model}\n\n"
        "Â¿CuÃ¡l es el aÃ±o de tu vehÃ­culo? (Ej: 2020, 2021, 2022)"
    )
    
    return VEHICLE_MODEL


async def get_vehicle_year(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Obtiene el aÃ±o del vehÃ­culo"""
    year_text = update.message.text.strip()
    
    try:
        year = int(year_text)
        current_year = 2024
        
        if year < 1900 or year > current_year + 1:
            await update.message.reply_text(
                f"âŒ Por favor, ingresa un aÃ±o vÃ¡lido entre 1900 y {current_year + 1}:"
            )
            return VEHICLE_YEAR
            
    except ValueError:
        await update.message.reply_text(
            "âŒ Por favor, ingresa un aÃ±o vÃ¡lido (solo nÃºmeros):"
        )
        return VEHICLE_YEAR
    
    context.user_data['vehicle_year'] = year
    
    await update.message.reply_text(
        f"âœ… AÃ±o: {year}\n\n"
        "Â¿CuÃ¡l es la placa de tu vehÃ­culo? (Ej: ABC1234)"
    )
    
    return VEHICLE_YEAR


async def get_vehicle_plate(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Obtiene la placa del vehÃ­culo y muestra servicios disponibles"""
    plate = update.message.text.strip().upper()
    
    # DEBUG: Log para ver quÃ© placa se estÃ¡ procesando
    logger.info(f"ğŸ” Placa recibida: '{plate}' (longitud: {len(plate)})")
    print(f"ğŸ” Placa recibida: '{plate}' (longitud: {len(plate)})")
    
    # ValidaciÃ³n mÃ¡s flexible: solo verificar que no estÃ© vacÃ­a y tenga longitud razonable
    if len(plate) < 1 or len(plate) > 20:
        await update.message.reply_text(
            "âŒ Por favor, ingresa una placa vÃ¡lida (mÃ¡ximo 20 caracteres):"
        )
        return VEHICLE_PLATE
    
    context.user_data['vehicle_plate'] = plate
    
    logger.info(f"âœ… Placa guardada: {plate}")
    print(f"âœ… Placa guardada: {plate}")
    
    # Obtener servicios disponibles
    try:
        logger.info("ğŸ” Buscando servicios en la base de datos...")
        
        # Usar sync_to_async para acceder a la base de datos desde contexto asÃ­ncrono
        servicios = await sync_to_async(list)(Servicio.objects.all())
        print(f"ğŸ“Š Servicios encontrados: {len(servicios)}")
        
        if not servicios:
            await update.message.reply_text(
                "âŒ No hay servicios disponibles en este momento.\n"
                "Por favor, contacta al taller directamente."
            )
            logger.error("âŒ No se encontraron servicios en la base de datos")
            return ConversationHandler.END
        
        # Crear botones para servicios
        keyboard = []
        for servicio in servicios:
            keyboard.append([InlineKeyboardButton(
                f"{servicio.nombre_servicio} - ${servicio.costo}",
                callback_data=f"service_{servicio.id}"
            )])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        service_message = f"âœ… Placa: {plate}\n\nğŸ”§ *Selecciona el servicio que necesitas:*\n"
        
        await update.message.reply_text(
            service_message,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )
        
        logger.info("âœ… Servicios mostrados al usuario")
        print("âœ… Servicios mostrados al usuario")
        logger.info("ğŸ”„ Retornando estado SERVICE_SELECT")
        print("ğŸ”„ Retornando estado SERVICE_SELECT")
        return SERVICE_SELECT
        
    except Exception as e:
        logger.error(f"âŒ Error al obtener servicios: {e}")
        print(f"âŒ Error al obtener servicios: {e}")
        await update.message.reply_text(
            "âŒ Error al cargar los servicios. Por favor, intenta mÃ¡s tarde."
        )
        return ConversationHandler.END


async def select_service(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja la selecciÃ³n del servicio y va directamente a confirmaciÃ³n"""
    query = update.callback_query
    await query.answer()
    
    service_id = query.data.split('_')[1]
    
    try:
        # Usar sync_to_async para obtener el servicio
        servicio = await sync_to_async(Servicio.objects.get)(id=service_id)
        context.user_data['service'] = servicio
        
        # Preparar mensaje de confirmaciÃ³n
        service_message = (
            f"âœ… *Servicio seleccionado:*\n"
            f"ğŸ”§ {servicio.nombre_servicio}\n"
            f"ğŸ’° Costo: ${servicio.costo}\n"
            f"â±ï¸ DuraciÃ³n estimada: {servicio.duracion} minutos\n\n"
            f"ğŸ“‹ *Resumen de tu solicitud:*\n"
            f"ğŸ‘¤ Cliente: {context.user_data['name']}\n"
            f"ğŸ“ TelÃ©fono: {context.user_data['phone']}\n"
            f"ğŸš— VehÃ­culo: {context.user_data['vehicle_brand']} {context.user_data['vehicle_model']} ({context.user_data['vehicle_year']})\n"
            f"ğŸ”¢ Placa: {context.user_data['vehicle_plate']}\n\n"
            f"ğŸ¤– *Esta solicitud aparecerÃ¡ inmediatamente en Reparaciones Disponibles*\n"
            f"para que los mecÃ¡nicos puedan tomar tu trabajo.\n\n"
            f"Â¿Confirmas esta solicitud de reparaciÃ³n?"
        )
        
        # Crear botones de confirmaciÃ³n
        keyboard = [
            [InlineKeyboardButton("âœ… SÃ­, confirmar", callback_data="confirm_yes")],
            [InlineKeyboardButton("âŒ No, cancelar", callback_data="confirm_no")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            service_message,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )
        
        return CONFIRMATION
        
    except Exception as e:
        logger.error(f"âŒ Error al obtener servicio: {e}")
        await query.edit_message_text(
            "âŒ Servicio no encontrado. Por favor, selecciona otro."
        )
        return VEHICLE_PLATE


def create_date_keyboard():
    """Crea un teclado con las prÃ³ximas fechas disponibles"""
    from datetime import datetime, timedelta
    
    keyboard = []
    current_date = datetime.now()
    
    # Mostrar prÃ³ximos 7 dÃ­as
    for i in range(1, 8):
        date = current_date + timedelta(days=i)
        date_str = date.strftime("%Y-%m-%d")
        display_str = date.strftime("%d/%m/%Y (%A)")
        keyboard.append([InlineKeyboardButton(
            display_str,
            callback_data=f"date_{date_str}"
        )])
    
    return InlineKeyboardMarkup(keyboard)


async def select_date(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja la selecciÃ³n de fecha y muestra horas disponibles"""
    query = update.callback_query
    await query.answer()
    
    # DEBUG: Verificar quÃ© callback_data se estÃ¡ recibiendo
    logger.info(f"ğŸ” Callback data recibido: '{query.data}'")
    print(f"ğŸ” Callback data recibido: '{query.data}'")
    
    # Extraer fecha del callback_data
    if query.data.startswith('date_'):
        date_str = query.data[5:]  # Remover 'date_' del inicio
    else:
        date_str = query.data.split('_')[1] if len(query.data.split('_')) > 1 else query.data
    
    logger.info(f"ğŸ” Fecha extraÃ­da: '{date_str}'")
    print(f"ğŸ” Fecha extraÃ­da: '{date_str}'")
    
    context.user_data['date'] = date_str
    
    # Convertir string a fecha
    from datetime import datetime
    try:
        selected_date = datetime.strptime(date_str, "%Y-%m-%d").date()
        display_date = selected_date.strftime("%d/%m/%Y")
    except ValueError as e:
        logger.error(f"âŒ Error al parsear fecha '{date_str}': {e}")
        await query.edit_message_text(
            f"âŒ Error al procesar la fecha: {date_str}\n"
            f"Por favor, selecciona otra fecha."
        )
        return SERVICE_SELECT
    
    # Obtener horas disponibles
    available_hours = get_available_hours(date_str)
    
    if not available_hours:
        await query.edit_message_text(
            f"âŒ No hay horas disponibles para el {display_date}.\n"
            "Por favor, selecciona otra fecha."
        )
        return SERVICE_SELECT
    
    # Crear teclado con horas disponibles
    keyboard = []
    for hour in available_hours:
        keyboard.append([InlineKeyboardButton(
            hour,
            callback_data=f"time_{hour}"
        )])
    
    async def create_appointment_in_db(data):
    """Crea la reparaciÃ³n en la base de datos para que aparezca en Reparaciones Disponibles"""
    try:
        from datetime import datetime, time
        
        # Obtener o crear cliente usando telÃ©fono como identificador Ãºnico
        # Usamos un email temporal pero verificamos por telÃ©fono para evitar duplicados
        try:
            cliente = await sync_to_async(Cliente.objects.get)(telefono=data['phone'])
            # Actualizar nombre si es diferente
            if cliente.nombre != data['name'].split()[0]:
                cliente.nombre = data['name'].split()[0]
                cliente.apellido = ' '.join(data['name'].split()[1:]) if len(data['name'].split()) > 1 else ''
                await sync_to_async(cliente.save)()
        except Cliente.DoesNotExist:
            # Crear nuevo cliente con email temporal Ãºnico
            import uuid
            temp_email = f"telegram_{data['phone']}_{uuid.uuid4().hex[:8]}@bot.local"
            cliente = await sync_to_async(Cliente.objects.create)(
                correo_electronico=temp_email,
                nombre=data['name'].split()[0],  # Primer nombre
                apellido=' '.join(data['name'].split()[1:]) if len(data['name'].split()) > 1 else '',  # Resto
                telefono=data['phone'],
                direccion='Cliente Telegram'  # DirecciÃ³n temporal
            )
        
        # Verificar si el vehÃ­culo ya existe para este cliente
        try:
            vehiculo = await sync_to_async(Vehiculo.objects.get)(
                cliente=cliente,
                placa=data['vehicle_plate']
            )
            # Actualizar datos del vehÃ­culo si son diferentes
            if (vehiculo.marca != data['vehicle_brand'] or 
                vehiculo.modelo != data['vehicle_model'] or 
                vehiculo.aÃ±o != data['vehicle_year']):
                vehiculo.marca = data['vehicle_brand']
                vehiculo.modelo = data['vehicle_model']
                vehiculo.aÃ±o = data['vehicle_year']
                await sync_to_async(vehiculo.save)()
        except Vehiculo.DoesNotExist:
            # Crear nuevo vehÃ­culo
            vehiculo = await sync_to_async(Vehiculo.objects.create)(
                cliente=cliente,
                marca=data['vehicle_brand'],
                modelo=data['vehicle_model'],
                aÃ±o=data['vehicle_year'],
                placa=data['vehicle_plate']
            )
        
        # Crear reparaciÃ³n directamente (no Agenda) para que aparezca en Reparaciones Disponibles
        reparacion = await sync_to_async(Reparacion.objects.create)(
            vehiculo=vehiculo,
            servicio=data['service'],
            mecanico_asignado=None,  # Sin asignar para que aparezca como disponible
            condicion_vehiculo='regular',  # CondiciÃ³n por defecto
            estado_reparacion='pendiente',  # Estado pendiente para que los mecÃ¡nicos puedan tomarla
        )
        
        logger.info(f"âœ… ReparaciÃ³n creada exitosamente: Cliente {cliente.nombre} ({cliente.telefono}), VehÃ­culo {vehiculo.marca} {vehiculo.modelo} ({vehiculo.placa}), ReparaciÃ³n ID {reparacion.id}")
        return True
        
    except Exception as e:
        logger.error(f"âŒ Error al crear reparaciÃ³n en BD: {e}")
        import traceback
        logger.error(f"Traceback: {traceback.format_exc()}")
        return False


async def cancel_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancela la conversaciÃ³n actual"""
    await update.message.reply_text(
        "âŒ *Proceso cancelado*\n\n"
        "Si quieres agendar una cita, usa /start nuevamente."
    )
    
    return ConversationHandler.END


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Muestra mensaje de ayuda"""
    help_text = """
ğŸ”§ *Ayuda del Bot del Taller MecÃ¡nico* ğŸ”§

Comandos disponibles:
/start - Iniciar proceso de agendar cita
/cancel - Cancelar el proceso actual
/help - Mostrar este mensaje de ayuda

ğŸ“ *Contacto del taller:*
[TelÃ©fono del taller]
[DirecciÃ³n del taller]

â° *Horario de atenciÃ³n:*
Lunes a Viernes: 8:00 AM - 6:00 PM
SÃ¡bados: 8:00 AM - 12:00 PM
"""
    
    await update.message.reply_text(help_text, parse_mode='Markdown')
